# 为什么要刷题
自己本身没有系统性地深入学习过算法。毕业之后的这些年，其实更多地是在做一些工程上面的事情。之前互联网一路高歌的年代，我们更关心的是，如何快速地把事情做成。  
并且如果数据量飞速增长的话，其实最优算法本身的意义并不是很大，就比如O(n)和O(n^2)的算法，如果n只是1000，在现代计算机的高速发展之下，这些用户感知到的差异很小，或者甚至都无感知。但当数据量达到百万、千万甚至亿级别的时候，算法的优势就逐渐显现了。

互联网公司是一个边际效应指数级增长的行业，所以其肯定是希望能够招到最优秀的人，去最大化产出，而这其中除了工作背景，以及系统设计等方面的考量之外，能够在更短时间【每轮面试1小时，一般技术面3-4轮】内考察一个人的水平，算法确实是一种很好的区分方式，因为这需要面试者大量的练习与思考。

## 对于自身的成长
刷题本身是为了让我们更深入的了解和运用各种算法，其实是换一个角度来说，这也是对于各个复杂系统的简单抽象。虽然当前主要面对的都是工程方面的问题，但是我们工程上将一个个问题拆解为一个个子模块，其实每个子模块要有极致效能，最终肯定是离不开算法的。

## 对于招聘的公司
并且对于公司而言，其实写题是一种相对而言更为准确的考察方式：
1、可以考察工程师的编码习惯
2、可以通过对于时间复杂度空间复杂度的考察判断工程师的算法基础
3、了解计算机的思维能力
所以我们在平时就算写题，也要注意良好的命名与注释，将这个优秀的习惯随时保持

## 关于项目的目录结构
当前主要是把自己认为应该放在一类的，比如动态规划（dp），树（tree）这种先放在一起，其它的题目还是会以题目的名字来命名，后期可以随着自己对各个算法的理解，再不断进行迭代。重要的是先run起来，把整个模式先运转起来。

## 关于项目的语言
目前因为golang是主要的学习语言，并且自己判断，在云原生时代，k8s已经成为云原生的基建，golang的重要性还会得到进一步的提升，作为性能与易用性的trade off的代表

## 刷题一段时间之后的感受
刷题确实让自己对很多计算机的精妙算法有了进一步的了解，而不是纯工程上的最佳实践，工程的目的是把事情做成，而算法的一些优化，可以让我们去把事情做得更好。比如之前这个计算完成需要几天，优化之后可能几小时，甚至几分钟就能计算出结果，或者是一些空间上的优化，比如类似于布隆过滤器或者bitmap，bitset之类的空间优化，可以使计算的存储成本大幅降低。

目前自己虽然对整个题目的大盘于考察要求有了一个比较全局的了解，但一些细节上的认知其实还远远不够，比如对于链表的一些操作，还有双向链表，以及对于图论这块，整个的知识版图还是没有完全补全，还是要不断刷题，不断归类总结，秉持“把手弄脏”的哲学，不断前行！

其实刷题也是一件熟能生巧的事情，最重要的是有思考与归纳总结，尤其是同一种类型的题目，自己想明白究竟整个流程是什么样子
很多时候，思考方式也都是自顶向下的，先有个自己的roadmap
