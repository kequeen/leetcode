# 为什么要刷题
1. 因为自己的计算机算法基础差，过去也没有特别专注去研究过算法，大都浅尝辄止，并没有进行过系统性的学习。毕业之后的这些年，其实更多地是在做一些工程上面的事情。之前互联网一路高歌的年代，我们更关心的是，如何快速地把事情做成。
2. 并且如果数据量飞速增长的话，其实最优算法本身的意义并不是很大，就比如O(n)和O(n^2)的算法，如果n只是1000，在现代计算机的高速发展之下，这些用户感知到的差异很小，或者甚至都无感知。但当数据量达到百万、千万甚至亿级别的时候，算法的优势就逐渐显现了。
3. 互联网公司是一个边际效应指数级增长的行业，所以其肯定是希望能够招到最优秀的人，去最大化产出，而这其中除了工作背景，以及系统设计等方面的考量之外，能够在更短时间【每轮面试1小时，一般技术面3-4轮】内考察一个人的水平，算法确实是一种很好的区分方式，因为这需要面试者大量的练习与思考。

## 对于自身的成长
刷题本身是为了让我们快速了解各种常用的算法，现代计算机行业发展到现在，针对很多的常见问题，其实已经有了一些公认的最优解。刷题算是一种快速学习前人优秀经验的过程。
其实是换一个角度来说，这也是对于各个复杂系统的简单抽象的练习。

虽然当前工作主要面对的都是工程方面的问题，但是我们工程上的大问题拆解为一个个子问题或者子模块，其实每个子模块要有极致效能，最终优化肯定是离不开算法的。（读乔布斯传 + 听半拿铁的播客，了解到以前的工程师都是精通硬件和软件的）

我们当今的优化都只能优化软件层面的，实在是有点遗憾。

## 对于招聘的公司
并且对于公司而言，其实写题是一种相对而言更具性价比的考察方式：
1. 可以快速考察工程师的编码习惯
2. 可以通过对于时间复杂度空间复杂度的考察判断工程师的算法基础
3. 针对一个简化版的场景进行沟通，了解行业
所以我们在平时就算写题，也要注意良好的命名与注释，保持这个习惯，这样在面试的时候，面试官会更容易理解你的代码。

## 关于项目的目录结构
当前主要是把自己认为应该放在一类的，比如动态规划（dp），树（tree）这种先放在一起，其它的题目还是会以题目的名字来命名，后期可以随着自己对各个算法的理解，再不断进行迭代。重要的是先run起来，把整个模式先运转起来。

## 关于项目的语言
1. 目前golang是主要的学习语言，
2. 并且自己判断，在未来，作为性能与易用性的trade off的代表，golang的重要性还会得到进一步的提升。

## 刷题一段时间之后的感受
刷题确实让自己对很多计算机的精妙算法有了进一步的了解，而不是纯工程上的最佳实践，工程的目的是把事情做成，而算法的一些优化，可以让我们去把事情做得更好。比如之前这个计算完成需要几天，优化之后可能几小时，甚至几分钟就能计算出结果，或者是一些空间上的优化，比如类似于布隆过滤器或者bitmap，bitset之类的空间优化，可以使计算的存储成本大幅降低。

目前自己虽然对整个题目的大盘于考察要求有了一个比较全局的了解，但一些细节上的认知其实还远远不够，比如对于链表的一些操作，还有双向链表，以及对于图论这块，整个的知识版图还是没有完全补全，还是要不断刷题，不断归类总结，秉持“把手弄脏”的哲学，不断前行！

其实刷题也是一件熟能生巧的事情，最重要的是有思考与归纳总结，尤其是同一种类型的题目，自己想明白究竟整个流程是什么样子
很多时候，思考方式也都是自顶向下的，先建设好自己的roadmap！
