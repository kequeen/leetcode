# 回溯法
关于回溯法，其核心是判断终止条件，然后进行回溯。
会比较依赖于深度优先搜索，去进行完整的回溯


## 经典的N皇后问题的优化
在解决 n 皇后问题时，需要确保每个皇后放置后，都不会与其他皇后在同一列、主对角线或次对角线上冲突。对于列的冲突，我们直接使用一个集合来记录已经被占用的列位置。但对角线的冲突需要一些特别的处理，这里就涉及到 `diagonals1` 和 `diagonals2`。

### 对角线冲突的解释：

1. **主对角线（从左上到右下）**:
   - 主对角线上的所有元素具有相同的 `row - col` 值。例如，在一个 4x4 的棋盘上：
     ```
     (0,0), (1,1), (2,2), (3,3) -> row - col = 0
     (0,1), (1,2), (2,3)       -> row - col = -1
     (1,0), (2,1), (3,2)       -> row - col = 1
     ```
   - 因此，`diagonals1` 这个集合存储的是所有已经放置了皇后的主对角线的 `row - col` 值。如果新的皇后要放置的地方 `row - col` 与集合中已有的值相同，说明这个位置与之前的皇后在同一条主对角线上，会发生冲突。

2. **次对角线（从右上到左下）**:
   - 次对角线上的所有元素具有相同的 `row + col` 值。例如，在一个 4x4 的棋盘上：
     ```
     (0,3), (1,2), (2,1), (3,0) -> row + col = 3
     (0,2), (1,1), (2,0)       -> row + col = 2
     (0,1), (1,0)              -> row + col = 1
     ```
   - 因此，`diagonals2` 这个集合存储的是所有已经放置了皇后的次对角线的 `row + col` 值。如果新的皇后要放置的地方 `row + col` 与集合中已有的值相同，说明这个位置与之前的皇后在同一条次对角线上，会发生冲突。

### 代码中的具体解释：
```python
# 检查主对角线冲突
diagonals1.add(row - col)

# 检查次对角线冲突
diagonals2.add(row + col)
```

- `row - col`：用来唯一标识主对角线。对于每个皇后，我们计算其 `row - col` 的值，并将其存入 `diagonals1` 集合中，表示这一条主对角线已经有一个皇后了。
- `row + col`：用来唯一标识次对角线。对于每个皇后，我们计算其 `row + col` 的值，并将其存入 `diagonals2` 集合中，表示这一条次对角线已经有一个皇后了。

在回溯过程中，如果要尝试放置一个新的皇后，首先会检查 `diagonals1` 和 `diagonals2` 中是否已经存在相同的 `row - col` 或 `row + col` 值。如果存在，说明这个位置和已有的皇后在同一条对角线上，是无效的放置，必须跳过。

通过这种方法，我们可以有效地避免放置皇后时产生的对角线冲突。